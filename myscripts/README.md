# Разные вспомогательные скрипты

Это примеры скриптов для работы с CSV, форматомЮ выводом данных, которые нужно модифицировать переменные в каждом конкретном случае использования.

**Содержание:**

* [Вывод CSV-файлов](#Вывод-CSV-файлов)
  * [вывод CSV в таблицу-лесенку](#Вывод-CSV-в-таблицу-лесенку)
  * [вывод CSV в форматированную таблицу](#вывод-CSV-в-форматированную-таблицу)
* [Экспорт CSV-файлов](#Экспорт-CSV-файлов)
  * [экспорт CSV-файлов в html](#Экспорт-CSV-файлов-в-html)
* [Проверка формата CSV-файлов](#Проверка-формата-CSV-файлов)
  * [проверка служебных символов CSV](#Проверка-служебных-символов-CSV)
* [Типы данных в полях CSV-файлов](#Типы-данных-в-полях-CSV-файлов)
  * [тип данных для денег UNIX-money](#Тип-данных-для-денег-UNIX-money)
  * [проверка числа](#Проверка-числа)
  * [проверка диапазона чисел](#Проверка-диапазона-чисел)
  * [проверка длинны строки](#Проверка-длинны-строки)
  * [проверка даты](#Проверка-даты)
  * [проверка периода времени](#Проверка-периода-времени)
* [Форматирование и вывод](#Форматирование-и-вывод)
  * [Форматирование строки "%Ns"](#Форматирование-строки-UTF-для-printf)
* [Системные возможности](#Системные-возможности)
  * [Проверка наличия команды или программы](#проверка-наличия-команды-или-программы)


## Вывод CSV-файлов

### Вывод CSV в таблицу-лесенку

**[csv2step.sh](csv2step.sh)**  -- примерный Bash-скрипт, который переводит csv-файл (переменная `nameFileCSV`) в таблицу-лесенку. 

Переменная `CSVseparator` -- разделитель полей в csv-файле.

Например, стандартный csv:

```
Дата;Время;Систоличкское;Диастолическое;Пульс;Заметка
2021-06-02;09:25;136;86;64;г-ка Шишонина
```
Вывод этой таблицы лесенкой

```
Дата
 Время
  Систоличкское
   Диастолическое
    Пульс
     Заметка
2021-06-02
 09:25
  136
   86
    64
     г-ка Шишонина
```
Скрипт будет неправильно работать в случае, если в поле CSV-файла будут по каким-то причинам находиться символы переноса строки, разделитель полей CSV. И  скрипт требует, по идее, предварительной проверки или замены этих символов.


### Вывод CSV в форматированную таблицу

**[csv2table.sh](csv2table.sh)** -- примерный Bash-скрипт, который переводит csv-файл в форматированную таблицу.

Изменять переменные:  
`nameFileCSV` -- csv-файл  
`table_format` -- строка спецификаторов для printf  
`CSVseparator` -- разделитель полей в csv-файле

Например, стандартный csv:

```
2021-01-03;11:00;136;84;74;г-ка Шишонина
...
```

Вывод этой таблицы в форматированную таблицу

```
$ ./csv2table.sh 
| 2021-01-03 | 11:00 | 136 | 84 | 74 | г-ка Шишонина |
| 2021-01-06 | 11:00 | 130 | 84 | 78 | г-ка Шишонина |
| 2021-01-07 | 10:00 | 156 | 84 | 74 |
| 2021-01-09 | 11:00 | 140 | 88 | 80 | г-ка Шишонина |
| 2021-01-12 | 11:00 | 144 | 82 | 70 | г-ка Шишонина |
| 2021-01-15 | 11:00 | 140 | 82 | 70 | 
```
Скрипт будет неправильно работать в случае, если в поле CSV-файла будут по каким-то причинам находиться символы переноса строки, разделитель полей CSV. И  скрипт требует, по идее, предварительной проверки или замены этих символов.


## Экспорт CSV-файлов

### Экспорт CSV-файлов в html

**[csv2html.sh](csv2html.sh)** -- примерный Bash-скрипт, который переводит csv-файл (переменная `nameFileCSV`) в html-таблицу.

Переменная `CSVseparator` -- разделитель полей в csv-файле.

    $ csv2html.sh > myhtmltable.html
    
Скрипт будет неправильно работать в случае, если в поле CSV-файла будут по каким-то причинам находится символы переноса строки, разделитель полей CSV. И  скрипт требует, по идее, предварительной проверки или замены этих символов.


## Проверка формата CSV-файлов

Невозможно создать алгоритм, который сможет правильно прочитать строку в CSV-файле в случае, если в поле CSV-файла будут по каким-то причинам находится символы переноса строки, разделитель полей CSV. Проверка на правильность формата CSV должна происходить при формированиии поля и при последующей записи в файл.


### Проверка служебных символов CSV

**[checkFormatCSV.sh](checkFormatCSV.sh)** -- это примерная функция Bash для проверки и замены служебных символов для поля формата CSV.
* Меняет разделитель полей CSV (обычно "," или ";") на другой символ
* Меняет символ `"` на `'`, если есть
* Меняет символ "\n" на "\u000A"

Требует три позиционных параметра:
* `$1` - строка поля CSV-файла
* `$2` - разделитель полей CSV-файла
* `$3` - замена для разделителя полей CSV-файла

Скрипт содержит объявление функции `checkFormatCSV` и пример её использования


## Типы данных в полях CSV-файлов

В CSV-файлах можно организовать и типы данных, превращая CSV  в подобие электронных таблиц или БД. Это такие типы данных как число, строка, дата, время, деньги.  Например, можно в скриптах для создания CSV-файлов организовать проверку типов вводимых данных перед записью строки CSV в файл.


### Тип данных для денег UNIX-money

[umoney.sh](umoney.sh) -- примерная реализация UNIX-money. Мой тип данных для денег. Umoney использует для записи количества денег минимальную денежную единицу
 * копейка в валюте рубль/копейка
 * цент в валюте доллар/цент

По аналогии с типом данных Unix time, что использует минимальную единицу времени секунду, тип данных UNIX-money является всегда целым числом

**umoney** -- примерная функция превращает запись типа "123 456 567,56" (123456567руб 56коп) в "12345656756" копеек

* Принимает параметр в виде "рубли,копейки"
* Возвращает UNIX-money в копейках
 
Пример вызова:

    umoney 12345,67
    umoney "23 312 345,67"

Зависит от переменные среды LC_NUMERIC. Текущая версия функции только для русской локали RU. 

Функция будет совершенствоваться:

* Обратный перевод из UNIX-money в "рубли,копейки"
* Доллар/цент

Скрипт содержит объявление функции `umoney` и пример её использования


### Проверка числа

**[checkDigit.sh](checkDigit.sh)** -- это примерная функция Bash для проверки являются ли данные числом
* врзвращает TRUE или FALSE
* проверяет:
  * целые положительные и отрицательные числа
  * числа с точкой или запятой
  * числа в научной нотации (экспоненциальная запись) 

Требует один позиционный параметр
* `$1` - переменная для поля CSV-файла

Скрипт содержит объявление функции `checkDigit` и пример её использования


### Проверка диапазона чисел

**[checkRange.sh](checkRange.sh)** -- примерная функция проверки целого числа в заданном диапазоне целых чисел

Принимает три позиционных аргумента
* $1 -- проверяемое число
* $2 -- начало диапазона
* $3 -- конец диапазона
Возвращает TRUE/FALSE

Пример вызова

    checkRange 1 2 3

Скрипт содержит объявление функции `checkRange` и пример её использования.


### Проверка длинны строки

**[checkLenStr.sh](checkLimStr.sh)** -- это примерная функция Bash для проверки длины строки

Принимает два позиционных параметра
* `$1` -- строка
* `$2` -- лимит длины строки
* врзвращает TRUE если строка БОЛЬШЕ числа длины

Скрипт содержит объявление функции `checkLimStr` и пример её использования


### Проверка даты

**[checkDate.sh](checkDate.sh)** -- это примерная функция Bash для проверки даты на коректность формата и календарное соответствие
 
Вызов функции:

    checkDate строка_даты [строка_формата_даты]

Принимает аргументы:
* `$1` -- проверяемая строка даты
* `$2` -- строка формата даты

Возвращает TRUE или FALSE

По умолчанию предполагается строка формата ISO 8601 `"Y-m-d"`, аргумент которого можно не указывать

    checkDate "2004-02-29"
    
Следующие строки формата даты нужно обязательно указывать в качестве аргумента:

**"Y/m/d"**

    checkDate "2004/02/29" "Y/m/d"

Скрипт содержит объявление функции `checkDate` и пример её использования


### Проверка периода времени

**[checkPeriod.sh](checkPeriod.sh)** -- функция проверки даты на принадлежность к периоду времени

Вызов функции:

    checkPeriod "YYYY-mm-dd" "YYYY-mm-dd" "YYYY-mm-dd"

Принимает три позиционных параметра в формате SO 8601 `"YYYY-mm-dd"`
* `$1` -- проверяемая дата
* `$2` -- дата начала периода
* `$3` -- дата начала периода
*  Возвращает `TRUE` или `FALSE`

Скрипт содержит объявление функции `checkPeriod` и пример её использования


## Форматирование и вывод

### Форматирование строки UTF для printf

**[prntfUTF](prntfUTF.sh)** -- функция форматирует строку в поле с заданной минимальной длинной. Если строка меньше поля, то добпвляются пробелы справа или слева строки. Замена `printf "%Ns"` для не латинских строк UTF-8.

Это "костыль" для решения проблемы с форматированием строк UTF-8 в `printf "%Ns"`. `printf` по разному выравнивает строки с разным числом байт на символ:

```sh
printf "latin string   : %5s\n" "qwe"
latin string   :   qwe
printf "cyrillic string: %5s\n" "йцу"
cyrillic string: йцу
```

Функция принимает два позиционных параметра
* `$1` -- строка
* `$2` -- длина поля
 Если ширина поля отрицательная, и длина строки меньше поля, то добавляем пробелы слева. Если ширина поля положительная, и длина строки меньше поля, то добавляем пробелы справа
 
Пример вызова

    prntfUTF "Привет мир" 10

 Пример с `printf`
 
    printf "The resolution $(prntfUTF "проблемы" 10) с UTF\n"
     
Переменные тоже нужно заключать в кавычки

    v="Привет мир"
    prntfUTF "$v" 10

**prArrUTF** -- функция для передачи масива в функцию `prntfUTF`. Тоже "костыль", в дальнейшем возможно объединение с prntfUTF.

Принимает лва аргумента
* `$1` -- имя массива без кавычек и "$"
* `$2` -- длина поля

Например:

    arrow=("привет мир" "hello world")
    prArrUTF arrow 16

Скрипт содержит объявление функций `prntfUTF`, `prArrUTF` и пример её использования.


## Системные-возможности

### проверка наличия команды или программы

**[checkComand.sh](checkComand.sh)** -- примерный скрипт, проверяющий наличие в системк команды или программы. Использует `type` для отображения информации о типе команды. Подавляет вывод `type`.
